ПЕРВОЕ: **ВСЕ КОНВЕРТЕРЫ ДОЛЖНЫ БЫТЬ БЫСТРЫМИ И ЛЁГКОВЕСНЫМИ ПО ПАМЯТИ.**

Ниже — архитектурные принципы и требования к Python‑конвертерам VKMax.

---

## 1. Форматы и цели

- **Вход**: `DOCX`, `PDF`.
- **Выход**:
  - `DOCX` (по сути: нормализованная копия исходника или результат конвертации PDF→DOCX),
  - `PDF` (из DOCX или исходного PDF),
  - **JSON‑GRAPH** (доменный граф, который генерирует LLM по тексту документа; далее может мапиться в React Flow, Mermaid и др.).

Ограничения:

- Вся тяжёлая работа (парсинг PDF/DOCX) должна быть *стриминг‑ориентированной* и по возможности избегать загрузки всего файла в память.
- Для LLM‑части достаточно первых **10 000 слов** текста документа.

---

## 2. Внутреннее представление (канонический формат)

Для упрощения оркестрации **НЕ** делаем HTML единственной канонической прослойкой.
Внутреннее представление должно быть минимальным и пригодным как для LLM, так и для базовых конверсий:

- **InternalDoc** (концепция, не класс):
  - `plain_text` — полный текст документа (без форматирования, или максимум первые N слов для LLM);
  - `meta` — язык, размер, количество страниц и т.п.;
  - (опционально) `html` — только там, где оно реально нужно (например, для HTML→PDF через pdfkit).

Принцип:

- Для **LLM / JSON‑GRAPH** нужен только `plain_text` (до 10 000 слов).
- HTML используем **точечно**, только для генерации PDF, когда это проще/стабильнее, чем прямой DOCX→PDF.

---

## 3. Когда использовать HTML‑прослойку

HTML имеет смысл как временное звено там, где есть готовые и надёжные библиотеки:

- **DOCX → HTML**: библиотека наподобие `mammoth` (уже в списке зависимостей) даёт достаточно качественный HTML.
- **HTML → PDF**: `pdfkit` + `wkhtmltopdf` хорошо решают эту задачу.

Поэтому HTML‑прослойка разумна в случаях:

1. **DOCX → PDF**:
   - DOCX → HTML (mammoth);
   - HTML → PDF (pdfkit/wkhtmltopdf).
2. **DOCX → DOCX** (нормализация, не обязательный сценарий):
   - Можно использовать путь через HTML, но чаще достаточно копирования/минимальных правок.

Для **LLM / JSON‑GRAPH** HTML НЕ обязателен:

- LLM легче и дешевле кормить либо чистым текстом, либо сильно упрощённым HTML.
- Для нашей задачи «первые 10 000 слов и построить JSON‑граф» достаточно **plain_text**.

Вывод: **HTML — вспомогательный формат для PDF**, а не глобальная прослойка для всего.

---

## 4. Стандартные пайплайны конвертации

### 4.1. DOCX как вход

- **DOCX → DOCX**:
  - Базовый сценарий: либо прямое копирование файла, либо минимальная нормализация.
  - Не требуются сложные преобразования.

- **DOCX → PDF**:
  - Предпочтительный путь с учётом доступных зависимостей:
    1. DOCX → HTML (mammoth или аналоги);
    2. HTML → PDF (pdfkit + wkhtmltopdf).
  - Важно: следить за размером HTML, по возможности не раздувать DOM (минимизировать стили, инлайновые шрифты и т.п.).

- **DOCX → JSON‑GRAPH** (через LLM):
  1. DOCX → `plain_text` (mammoth или `python-docx` / аналогичный парсер).
  2. Обрезать текст до 10 000 слов (по пробелам, с учётом unicode).
  3. Сформировать промпт для LLM (DeepSeek) с инструкцией: построить JSON‑граф, вернуть **ТОЛЬКО** JSON‑код.
  4. Отправить в LLM (через `LLM_SERVICE`), прогнать результат через `CleanerService` (`doc_type="graph_json"`).
  5. Сохранить JSON‑граф как файл выходного формата `GRAPH` (например, расширение `.graph.json`).

### 4.2. PDF как вход

- **PDF → PDF**:
  - Базовый сценарий – просто хранение/переупаковка (по возможности без повторного рендеринга).
  - Любые сложные преобразования по содержимому выполняются в других пайплайнах.

- **PDF → DOCX**:
  - Использовать профильный конвертер `pdf2docx`.
  - Важно: это тяжёлая операция, поэтому тщательно контролировать:
    - ограничение размера файла (40 МБ уже enforced на уровне FastAPI),
    - отключение ненужных картинок/шрифтов, если есть такие опции.

- **PDF → JSON‑GRAPH** (через LLM):
  1. PDF → `plain_text`:
     - либо напрямую через `fitz` (PyMuPDF), вытаскивая текст по страницам,
     - либо через цепочку PDF → DOCX → `plain_text` (дороже, но может давать более чистый текст там, где plain‑текст из PDF очень грязный).
  2. Обрезать текст до 10 000 слов.
  3. Дальнейшие шаги такие же, как в DOCX → MERMAID.

**Важно:** для графового пайплайна нам не нужно восстанавливать оформление; достаточно логической структуры текста.

---

## 5. Требования к реализациям конвертеров

1. **Быстродействие и память**:
   - избегать загрузки больших PDF/DOCX целиком в память, работать постранично/потоками, где это возможно;
   - для LLM‑пути после достижения 10 000 слов **немедленно прекращать дальнейшее чтение** тела документа;
   - по возможности не держать одновременно и исходный байтовый файл, и развёрнутый HTML/текст в памяти, если это не требуется.

2. **Чистота по зависимостям**:
   - конвертеры не должны знать о FastAPI или CACHE_MANAGER;
   - они работают только с путями к файлам и формальными параметрами (например, язык, режим качества).

3. **Строгий контракт ввода/вывода**:
   - каждая функция конвертера должна:
     - принимать путь к входному файлу + формат;
     - возвращать путь к выходному файлу + формат (или бросать контролируемое исключение с понятной причиной: неподдерживаемый формат, повреждённый документ, превышен лимит и т.п.).

4. **Логирование и диагностика**:
   - логировать основные шаги: старт конвертации, выбранный путь (напр. DOCX→HTML→PDF), статистику (количество страниц/слов).
   - не логировать полный текст документа, максимум короткие превью (50–100 символов).

5. **Изоляция LLM**:
   - генерация MERMAID‑графа должна быть выделена в отдельный слой (через `LLM_SERVICE`), конвертеры не должны напрямую обращаться к внешним API;
   - конвертеры предоставляют только `plain_text` (не более 10 000 слов) + метаданные; всё остальное делает LLM‑оркестратор.

---

## 6. Как это стыкуется с FastAPI и LLM_SERVICE (обзор)

- FastAPI (роуты `/convert`, `/files`, `/download`) отвечает за:
  - приём запросов, валидацию, работу с БД (через CACHE_MANAGER);
  - запуск Python‑конвертеров (BACKEND/CONVERT) в фоновом режиме/воркерах.

- BACKEND/CONVERT (этот модуль):
  - реализует чистые функции конвертации между файловыми форматами;
  - не хранит состояние, полностью независим от HTTP и БД.

- LLM_SERVICE:
  - принимает `plain_text` из конвертеров,
  - по заранее описанным промптам и task_id (например, `graph_from_document`) генерирует MERMAID‑код,
  - возвращает строку, которую конвертер сохраняет как файл формата `GRAPH`.

Такой разделение позволяет:

- легко тестировать конвертеры отдельно от API и LLM;
- при необходимости заменять конкретную реализацию (например, другой PDF‑парсер) без затрагивания FastAPI.