Подскажи, в рамках хакатона выдали API ключ как мне дальше быть
Также я сделал мини приложение теперь хочу подключить авторизацию через MAX 


одготовка и настройка бота
Подключение к платформе MAX для партнёров и её сервисам — чат-ботам, мини-приложениям, каналам — пока доступно для ограниченного списка юрлиц и ИП, которые разместили приложение в RuStore или зарегистрировались на МСП.РФ

Уровень сложности: продвинутый

С навыками разработки вы можете создавать чат-ботов с неограниченным потенциалом и возможностью размещать мини-приложения в MAX

В этом разделе разберём, как создаётся бот, как настроить его взаимодействие с API MAX, как управлять ботом и подключить к нему готовое мини-приложение

Подготовка
Бот создаётся при подключении к платформе MAX для партнёров

Для одной организации доступно создание 5 ботов

Пользователи могут получить доступ к боту после его успешной модерации. Статус модерации отображается рядом с названием бота

У бота в MAX есть следующие поля или настройки:

Имя, которое отображается в MAX в чате с вашим ботом, — задаётся при создании бота в поле Название
Аватар (фото профиля) — загружается в виде логотипа при создании бота
Ник, который отображается в публичной ссылке, например для max.ru/idИНН_bot ником является idИНН_bot. Он генерируется автоматически при создании бота по шаблону idИНН_bot
Описание для пользователя, где указано, какие задачи решает бот: что умеет, чем полезен, как связаться с его владельцем или поддержкой. Всё это указывается при создании бота в поле Описание
Имя, аватар и описание можно изменить. Отредактировать ник пока нельзя. При изменении настроек обратите внимание на требования к полям


Профиль бота

После успешной проверки бота в разделе Чат-бот и мини-приложение появится токен — уникальный идентификатор бота, с помощью которого он будет взаимодействовать с API MAX. Наличие токена означает, что бот зарегистрирован на платформе MAX для партнёров

При необходимости токен можно обновить. Также вы можете добавить ссылку на мини-приложение, которое хотите подключить к чат-боту

Пример токена

AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw

Токен — это прямой доступ к боту. Не рекомендуем хранить его в открытых источниках или передавать посторонним — они смогут завладеть ботом и управлять им от вашего имени. Если вы опасаетесь, что токен скомпрометирован, обновите его

ℹ️ Собрать сценарий для бота можно без кода, для этого есть конструкторы с набором готовых решений. Подробнее в разделе «Бот без разработки»

Отправляем API-запросы
API — это сервис, который позволяет взаимодействовать с платформой от имени бота. Бот отправляет запросы с токеном к API MAX и получает обновления с сервера в формате JSON

Передача токена через query-параметры больше не поддерживается — используйте заголовок Authorization: <token>

Вот так выглядит базовый запрос к API MAX.

Код
https://platform-api.max.ru/me?
Authorization: <token>
В ответ вернётся информация о боте — его имя, токен или ник

Если вы отправляете запросы на домен botapi.max.ru, перейдите на новый домен platform-api.max.ru до 1 октября. Это важно для стабильной работы ботов

Подробнее о работе с сервером, методах и параметрах запросов читайте в разделе «API»

Если вы пишете ботов на TypeScript или JavaScript, рекомендуем использовать нашу официальную библиотеку — она содержит разные стандартные методы и утилиты. Читайте подробнее в разделе «Библиотека MAX Bot API» здесь или на GitHub

Настраиваем уведомления
API MAX поддерживает два типа уведомлений о действиях пользователей с ботом — через Webhook и Long Polling. Использовать одновременно их нельзя — выберите один из типов

Технологии отправки уведомлений отличаются способом взаимодействия с сервером и продолжительностью отклика. Webhook после новых действий в чат-боте сам отправляет запрос на сервер, а Long Polling работает методом периодических запросов без триггера в боте

Чтобы подключить уведомления, отправьте к API POST-запрос /subscriptions. В запросе укажите URL, на который должна приходить информация о новых событиях с ботом

Webhook
Чтобы получить уведомления, выполните GET-запрос /subscriptions

Обратите внимание: для отправки вебхуков поддерживается только протокол HTTPS, включая самоподписанные сертификаты. HTTP не поддерживается

Long Polling
Чтобы получить уведомления, выполните GET-запрос /updates

Управляем ботом в MAX
Как изменить настройки бота
Изменить можно все настройки, кроме ника

Перейдите на платформу MAX для партнёров
Если у вас несколько ботов, в левом верхнем углу выберите нужный
Справа нажмите на значок настроек
Внесите изменения и нажмите Сохранить — бот будет отправлен на повторную модерацию.
Пока идёт проверка, бот остаётся в прежнем виде для конечных пользователей. Изменения применяются после успешной модерации
Где посмотреть токен бота
Перейдите на платформу MAX для партнёров
Если у вас несколько ботов, в левом верхнем углу выберите нужный
Перейдите в раздел Чат-бот и мини-приложение → Настроить — токен находится в поле с одноимённым названием
Как обновить токен бота
Перейдите на платформу MAX для партнёров
Если у вас несколько ботов, в левом верхнем углу выберите нужный
Перейдите в раздел Чат-бот и мини-приложение → Настроить
Справа от поля с токеном нажмите на значок обновления
Как удалить бота
ℹ️ После удаления ваши клиенты не смогут пользоваться ботом. Удалённого бота нельзя восстановить

Чтобы удалить:

Перейдите на платформу MAX для партнёров
Если у вас несколько ботов, в левом верхнем углу выберите нужный
Справа нажмите на значок настроек
Нажмите Удалить бота и подтвердите удаление
Добавляем мини-приложение в MAX
Подробнее о добавлении мини-приложений читайте в документации мини-приложений


ℹ️ Если у вас возникли вопросы, посмотрите раздел с ответами

Hello Bot
В этом разделе разберём пример реализации простого бота с использованием библиотеки MAX Bot API — напишем код для Hello Bot, чтобы научить его здороваться с пользователями

Больше примеров смотрите в нашем репозитории на GitHub

1. Создаём новый проект в терминале и устанавливаем библиотеку для своего менеджера пакетов. Используем скрипт curl или wget

BASH
# Создайте папку и перейдите в неё
mkdir my-first-bot
cd my-first-bot


# Установите MAX Bot API

# Для npm
npm install --save @maxhub/max-bot-api
# Для yarn
yarn add @maxhub/max-bot-api
# Для pnpm
pnpm add @maxhub/max-bot-api
# Для deno
deno add npm:@maxhub/max-bot-api

# Установите и настройте TypeScript (опционально)
yarn add -D typescript
npx tsc --init
2. Создаём файл. Для JavaScript — bot.js, для TypeScript — bot.ts

3. Создаём объект класса Bot — он обеспечит доступ к методам и утилитам

JS
import { Bot } from '@maxhub/max-bot-api';
const bot = new Bot(process.env.BOT_TOKEN); // Токен, полученный при регистрации бота в MAX
bot.start(); // Запускает получение обновлений
bot.js
4. Закладываем функциональность приветствия — наш бот будет отвечать на команду /hello

JS
import { Bot } from '@maxhub/max-bot-api';
const bot = new Bot(process.env.BOT_TOKEN);

// Устанавливает список команд, который пользователь будет видеть в чате с ботом
bot.api.setMyCommands([
  {
    name: 'hello',
    description: 'Поприветствовать бота',
  },
]);

// Обработчик команды '/hello'
bot.command('hello', (ctx) => {
  return ctx.reply('Привет! ✨');
});
bot.start();
bot.js
5. Тестируем бота — отправляем команду /hello


Чат с Hello Bot

6. Сделаем приветствие адресным — укажем имя пользователя, который отправил сообщение, и проверим результат командой /hello

JS
import { Bot } from '@maxhub/max-bot-api';
const bot = new Bot(process.env.BOT_TOKEN);
bot.api.setMyCommands([
  {
    name: 'hello',
    description: 'Поприветствовать бота',
  },
]);

bot.command('hello', (ctx) => {
  const user = ctx.user(); // Получаем данные пользователя из нового события

  if (!user) {
    // Если пользователя не получилось определить, просто поздороваемся 
    return ctx.reply('Привет! ✨');
  }

  // Если пользователя определён, поздороваемся адресно
  return ctx.reply(`Привет, ${ctx.user()}! ✨`);
});
bot.start();
bot.js
Готово! Мы написали простого и дружелюбного Hello Bot. Воспользуйтесь возможностями и инструментами платформы MAX, чтобы запустить на платформе собственные проекты


Чат с Hello Bot


ℹ️ Если у вас возникли вопросы, посмотрите раздел с ответами

Библиотека JavaScript
Если вы пишете ботов на TypeScript или JavaScript, рекомендуем использовать нашу официальную библиотеку MAX Bot API. Расширенную версию библиотеки с примерами реализации смотрите на GitHub

В этом разделе разберём, как подключить библиотеку MAX Bot API и эффективно использовать стандартные методы и утилиты, которыми она располагает

Устанавливаем MAX Bot API
Чтобы установить библиотеку MAX Bot API, зарегистрируйте бота на платформе и подключитесь к API MAX — следуйте подсказкам в разделе «Подготовка и управление»

Все примеры в этом разделе написаны на JavaScript с переменными окружения в Node.js

1. Создайте новый проект в терминале и установите библиотеку для своего менеджера пакетов. Используйте скрипт curl или wget

BASH
# Создайте папку и перейдите в неё
mkdir my-first-bot
cd my-first-bot

# Установите MAX Bot API

# Для npm
npm install --save @maxhub/max-bot-api
# Для yarn
yarn add @maxhub/max-bot-api
# Для pnpm
pnpm add @maxhub/max-bot-api
# Для deno
deno add npm:@maxhub/max-bot-api

# Установите и настройте TypeScript (опционально)
yarn add -D typescript
npx tsc --init
2. Создайте файл. Для JavaScript — bot.js, для TypeScript — bot.ts

3. Создайте экземпляр класса Bot и передайте токен из его настроек (карточки) в конструктор через переменные окружения. Можно использовать библиотеку dotenv

JS
import { Bot } from '@maxhub/max-bot-api';

// Создайте экземпляр класса Bot и передайте ему токен 
const bot = new Bot(process.env.BOT_TOKEN);

// Добавьте слушатели обновлений
// MAX Bot API будет вызывать их, когда пользователи взаимодействуют с ботом

// Обработчик для команды '/start'
bot.command('start', (ctx) => ctx.reply('Добро пожаловать!'));

// Обработчик для любого другого сообщения
bot.on('message_created', (ctx) => ctx.reply('Новое сообщение'));

// Теперь можно запустить бота, чтобы он подключился к серверам MAX и ждал обновлений
bot.start();
bot.js
4. Запустите бота

BASH
# Скомпилируйте код, если вы использовали TypeScript
npx tsc

# Передайте переменную окружения и запустите бота
BOT_TOKEN="<your_token_here>" node bot.js
Работаем с обновлениями
После запуска вы начнёте получать обновления от MAX — следите за подсказками в редакторе кода. MAX Bot API позволяет прослушивать эти обновления

JS
// Обработчик начала диалога с ботом
bot.on('bot_started', (ctx) => {/* ... */});

// Обработчик новых сообщений (с ним callback в bot.hears работать не будет)
bot.on('message_created', (ctx) => {/* ... */});

// Обработчик удаления сообщения (с ним callback в bot.hears работать не будет)
bot.on('message_removed', (ctx) => {/* ... */});

// Обработчик редактирования сообщения (с ним callback в bot.hears работать не будет)
bot.on('message_edited', (ctx) => {/* ... */});

// Обработчик добавления бота в чат (с ним callback в bot.hears работать не будет)
bot.on('bot_added', (ctx) => {/* ... */});

// Обработчик удаления бота из чата (с ним callback в bot.hears работать не будет)
bot.on('bot_removed', (ctx) => {/* ... */});

// Обработчик добавления пользователя в беседу
bot.on('user_added', (ctx) => {/* ... */});

// Обработчик удаления пользователя из беседы
bot.on('user_removed', (ctx) => {/* ... */});

// Обработчик изменения названия беседы
bot.on('chat_title_changed', (ctx) => {/* ... */});

// Обработчик callback-сообщения
bot.on('message_callback', (ctx) => {/* ... */});
Входящие сообщения
Вы можете подписаться на обновления message_created

JS
bot.on('message_created', (ctx) => {
  const message = ctx.message; // Полученное сообщение
});
Или воспользуйтесь специальными методами

JS
// Обработчик команды '/start'
bot.command('start', async (ctx) => {/* ... */});

// Сравнение текста сообщения со строкой или регулярным выражением
bot.hears('hello', async (ctx) => {/* ... */});
bot.hears(/echo (.+)?/, async (ctx) => {/* ... */});

// Обработчик нажатия на callback-кнопку с указанным payload
bot.action('connect_wallet', async (ctx) => {/* ... */});
bot.action(/color:(.+)/, async (ctx) => {/* ... */});
Исходящие сообщения
Воспользуйтесь методами из bot.api

JS
// Отправить сообщение пользователю с id=12345
await bot.api.sendMessageToUser(12345, "Привет!");
// Опционально можно передать дополнительные параметры
await bot.api.sendMessageToUser(12345, "Привет!", {/* доп. параметры */});

// Отправить сообщение в чат с id=54321
await bot.api.sendMessageToChat(54321, "Всем привет!");

// Получить отправленное сообщение
const message = await bot.api.sendMessageToUser(12345, "Привет!");
console.log(message.body.mid);
ℹ️ Если MAX Bot API не поддерживает какой-то метод, вызовите его через ctx.api.raw

Форматы методов Raw API

JS
ctx.api.raw.get('method', {/* параметры запроса */});
ctx.api.raw.post('method', {/* параметры запроса */});
ctx.api.raw.put('method', {/* параметры запроса */});
ctx.api.raw.patch('method', {/* параметры запроса */});
ctx.api.raw.delete('method', {/* параметры запроса */});

// Вызов метода редактирования чата с id=123
await ctx.api.raw.patch('chats/{chat_id}', {  
    path: { chat_id: 123 }, // Параметры ссылки
    body: { title: 'New Title' }, // Тело запроса
    query: { notify: false }, // Параметры поиска
});
Можно обратиться к методу контекста reply

JS
bot.hears('ping', async (ctx) => {
    // 'reply' — псевдоним метода 'ctx.api.sendMessageToChat' в этом же чате
    await ctx.reply('pong', {
        // 'link' прикрепляет оригинальное сообщение
        link: { type: 'reply', mid: ctx.message.body.mid },
    });
});
Форматирование сообщений
Чтобы выделить в сообщениях важную информацию, используйте разные способы оформления текста — жирный шрифт, курсив, ссылки и другое. Есть два типа форматирования — Markdown и HTML

Markdown

JS
await bot.api.sendMessageToChat(
  12345,
  '**Привет!** _Добро пожаловать_ в [MAX](https://dev.max.ru).',
  { format: 'markdown' },
);
HTML

JS
await bot.api.sendMessageToChat(
  12345,
  '<b>Привет!</b> <i>Добро пожаловать</i> в <a href="https://dev.max.ru">MAX</a>.',
  { format: 'html' },
);
Отправляем вложения
Упростите работу с вложениями классом Attachment. Благодаря функции toJson объект вложения будет возвращаться отформатированным

Файлы

С помощью токена — для файлов, которые уже загружены в MAX
JS
const image = new ImageAttachment({ token: 'existingImageToken' });
await ctx.reply('', { attachments: [image.toJson()] });

const video = new VideoAttachment({ token: 'existingVideoToken' });
await ctx.reply('', { attachments: [video.toJson()] });

const audio = new AudioAttachment({ token: 'existingAudioToken' });
await ctx.reply('', { attachments: [audio.toJson()] });

const file = new FileAttachment({ token: 'existingFileToken' });
await ctx.reply('', { attachments: [file.toJson()] });
Чтобы загрузить файлы на серверы MAX, воспользуйтесь методом ctx.api

uploadImage
uploadVideo
uploadAudio
uploadFile
Загруженные файлы возвращают экземпляр класса Attachment

JS
const image = await ctx.api.uploadImage({ source: '/path/to/image' });
await ctx.reply('Это фото загружено из файла', {
  attachments: [image.toJson()],
});
С помощью ссылки — доступно только для изображений
JS
const image = await ctx.api.uploadImage({ url: 'https://upload.wikimedia.org/wikipedia/commons/7/72/Maxmessenger.png' });
await ctx.reply('', { attachments: [image.toJson()] });
Другие типы вложений

JS
const sticker = new StickerAttachment({ code: "stickerCode" });
await ctx.reply('', { attachments: [sticker.toJson()] });

const location = new LocationAttachment({ lon: 0, lat: 0 });
await ctx.reply('', { attachments: [location.toJson()] });

const share = new ShareAttachment({ url: "messagePublicUrl", token: "attachmentToken" });
await ctx.reply('', { attachments: [share.toJson()] });
Клавиатура
Клавиатура отображается в сообщениях бота и похожа на пульт управления. Пользователям не нужно печатать ответ на запрос, достаточно нажать на кнопку. Параметры и оформление клавиатуры можно настроить — используйте KeyboardBuilder

TYPESCRIPT
const keyboard = Keyboard.inlineKeyboard([
  // Первая строка с тремя кнопками
  [
    Keyboard.button.callback('default'),
    Keyboard.button.callback('positive', { intent: 'positive' }),
    Keyboard.button.callback('negative', { intent: 'negative' }),
  ], 
  // Вторая строка с одной кнопкой
  [Keyboard.button.link('Открыть MAX', 'https://max.ru')],
]);

// Далее мы можем отправить клавиатуру пользователю в сообщении, например, при вызове команды страт
bot.command('start', (ctx: Context) => {
  ctx.reply('Добро пожаловать!', {attachments: [keyboard]})
});
Параметры клавиатуры по умолчанию

Чтобы клавиатура оставалась удобной для пользователей, рекомендуем заранее продумать её наполнение и учитывать следующие параметры:

Текст на кнопке выравнивается по центру и обрезается, если выходит за её границы
Кнопки в одной строке должны быть одинаковой ширины
Ширина каждого ряда кнопок равна ширине клавиатуры
Высота у всех кнопок по умолчанию одинаковая
Inline-клавиатура

Такая клавиатура может иметь до 210 кнопок, сгруппированных в 30 рядов — до 7 кнопок в каждом (до 3, если это кнопки типа link, open_app, request_geo_location или request_contact). Если ряды кнопок не помещаются в плейсхолдер клавиатуры, автоматически подключается скролл


Inline-клавиатура в чат-боте

Типы кнопок
Кнопки для клавиатуры различаются по типу

CallbackButton
Информирует сервер о действиях в чат-боте и вызывает обновление message_callback

TYPESCRIPT
button.callback(text: string, payload: string, extra?: { 
  intent?: 'default' 
});
LinkButton
Позволяет открыть ссылку в новой вкладке

TYPESCRIPT
button.link(text: string, url: string);
RequestContactButton
Запрашивает разрешение на доступ к контактам телефонной книги, чтобы пользователь мог отправить в чат телефон или ник

TYPESCRIPT
button.requestContact(text: string);
RequestGeoLocationButton
Открывает окно с информацией о местоположении пользователя, чтобы он мог поделиться координатами в чате

TYPESCRIPT
button.requestGeoLocation(text: string, extra?: { quick?: boolean });
OpenAppButton
Открывает мини-приложение

TYPESCRIPT
button.openApp(text: string, webApp?: string, contactId?: number);
MessageButton
Отправляет боту текстовое сообщение

TYPESCRIPT
button.message(text: string);
Расширяем контекст
TYPESCRIPT
interface MyContext extends Context {
  isAdmin?: boolean;
}
const ADMIN_ID = 12345;
const bot = new Bot<MyContext>(process.env.BOT_TOKEN);
bot.use(async (ctx, next) => {
  ctx.isAdmin = ctx.user?.user_id === ADMIN_ID;
  return next();
});
bot.command('start', async (ctx) => {
  if (ctx.isAdmin) {
    return ctx.reply('Привет, админ!');
  }
  return ctx.reply('Привет!');
});
Поздравляем, вы написали первого бота!


ℹ️ Если у вас возникли вопросы, посмотрите раздел с ответами

Обзор
Подключение к платформе MAX для партнёров и её сервисам — чат-ботам, мини-приложениям, каналам — пока доступно для ограниченного списка юрлиц и ИП, которые разместили приложение в RuStore или зарегистрировались на МСП.РФ

Мини-приложения работают только внутри MAX и не могут существовать автономно. Они расширяют функциональность основной платформы и позволяют разработчикам быстро запускать проекты

Что потребуется
Устройства с операционной системой Windows, macOS или Linux
Мобильное устройство для регистрации профиля в MAX
Редактор кода и навыки работы с командной строкой
Что упростит разработку
Библиотека MAX Bridge, с которой мини-приложение сможет взаимодействовать с API MAX и API устройства пользователя
Библиотека React-компонентов MAX UI, с которой мини-приложение легко стилизовать под интерфейс MAX
Мини-приложения работают на базе стандартных веб-технологий — HTML, JavaScript, CSS
Перед подключением
Загрузите файлы мини-приложения на хостинг статики, например, через Vercel или GitHub Pages — .html, .css, .js и другие медиафайлы
Проверьте, что приложение работает по защищённому соединению — https
Как добавить приложение в MAX
Откройте платформу MAX для партнёров → выберите нужный чат-бот
Перейдите в раздел Чат-бот и мини-приложение → Настроить
Вставьте URL мини-приложения в поле для ссылки и нажмите Сохранить
Требования к URL мини-приложения:

Длина: не более 1024 символов
Протокол: только https://
Допустимые символы: буквы (латиница), цифры, точка (.) и дефис (-)
Пробелы запрещены
URL должен быть валидный
Как только вы подключите мини-приложение к платформе, в чате с его ботом появится заметная кнопка для быстрого запуска сервиса


Запуск мини-приложения из чата с ботом

Как управлять приложением
Обновление ссылки на приложение
Если ссылка поменялась, самостоятельно обновите её на платформе MAX для партнёров: зайдите в личный кабинет организации → перейдите в раздел Чат-бот и мини-приложение → Настроить → в поле с URL обновите ссылку → нажмите Сохранить

Удаление приложения
Если вы хотите удалить мини-приложение, удалите ссылку на него в платформе MAX для партнёров: зайдите в личный кабинет организации → перейдите в раздел Чат-бот и мини-приложение → Настроить → в поле с URL удалите ссылку → нажмите Сохранить

Как открыть приложение по прямой ссылке
Каждое мини-приложение можно открыть внутри MAX по ссылке вида: https://max.ru/<botName>?startapp

После ключа ?startapp в ссылку можно добавить стартовые параметры. Они будут переданы мини-приложению в поле start_param и в GET-параметре WebAppStartParam

Подробнее о стартовых параметрах читайте в разделе WebAppStartParam


ℹ️ Если у вас возникли вопросы, посмотрите раздел с ответами

Я разработал Мини приложение

MAX Bridge
Библиотека MAX Bridge позволяет мини-приложениям корректно взаимодействовать с API MAX и API операционной системы на устройстве пользователя. В этом разделе содержится список объектов и событий MAX Bridge

Подключение библиотеки
Добавьте библиотеку max-web-app.js

HTML
<script src="https://st.max.ru/js/max-web-app.js"></script>
С подключением библиотеки мини-приложение получит доступ к глобальному объекту WebApp в window и сценариям для его использования

Объекты
Window.WebApp
Этот глобальный объект связывает мини-приложение с клиентом и позволяет взаимодействовать с MAX, управлять интерфейсом приложения и получать информацию о пользователях. Объект window.WebApp создаётся с каждым запуском сервиса, предзагружает данные и не требует отдельной инициализации — его методы и параметры доступны напрямую

Версия приложения MAX передаётся в стартовых параметрах URL через WebAppVersion и доступна в свойстве version объекта window.WebApp. Этот параметр не участвует в формировании хеша для валидации — в хеше учитываются только данные из WebAppData

Поле	Входные параметры	Тип данных	Описание
initData	-	string	Объект со стартовыми параметрами, который как и WebAppData, применяется для отображения данных о пользователе в UI
initDataUnsafe	-	WebAppData	Объект со стартовыми параметрами, который не должен использоваться для валидации пользователей
platform	-	string	Платформа, с которой запущено мини-приложение.
Возможные значения: ios, android, desktop, web
version	-	string	Версия приложения MAX, с которого запущено мини-приложение.
Имеет формат <year>.<build_number — возрастающий счётчик>.<patch_version — для патчей>, например 25.9.16
onEvent()	eventName: string, callback: function	function	Подпишет на событие с использованием callback
offEvent()	eventName: string, callback: function	function	Отпишет callback от события
ready()	-	function	Сообщит MAX, что мини-приложение готово к работе
close()	-	function	Закроет мини-приложение
requestContact()	-	function	Попросит телефон у пользователя в нативном диалоговом окне
BackButton	-	BackButton	Управляет кнопкой Назад в шапке мини-приложения
ScreenCapture	-	ScreenCapture	Объект для управления возможностью делать скриншоты / записывать экран
HapticFeedback	-	HapticFeedback	Объект для управления тактильными вибро-откликами
enableClosingConfirmation()	-	function	Предупредит пользователя о риске потерять заполненные данные, если закрыть мини-приложение
disableClosingConfirmation()	-	function	Не предупредит пользователя о риске потерять заполненные данные, если закрыть мини-приложение
openLink()	url: string	function	Откроет ссылку во внешнем браузере
openMaxLink()	url: string	function	Откроет другое мини-приложение внутри MAX, закрыв текущее. Ссылка должна быть вида

https://max.ru/<botName>?startapp
shareContent()	text: string, link: string	function	Метод, который используется вызова нативного экрана шаринга
shareMaxContent()	text: string, link: string	function	Метод, который используется для вызова экрана шаринга внутри Max
downloadFile()	url: string, fileName: string	function	Метод, который используется для скачивания файла по переданной ссылке
openCodeReader()	fileSelect: boolean	function	Открыть камеру для считывания QR кода.

Клиент вернет результат в виде строки (если QR код был найден и распознан)
fileSelect = true - доступен так же выбор из галереи
fileSelect = false - доступно сканирование только через камеру


Если fileSelect не передан - по умолчанию считается true
WebAppData
Этот объект содержит данные, которые мини-приложение получает при запуске. Совпадает с initData

Параметр	Тип данных	Описание
query_id	string	Уникальный идентификатор сессии мини-приложения
auth_date	int32	Время получения данных с бэкенда
hash	string	Хэш переданных параметров, который можно использовать для проверки их достоверности
start_param	WebAppStartParam	Объект с дополнительными данными
user	object	Объект с данными о пользователе, который открывает мини-приложение
user.id	int64	Уникальный идентификатор пользователя MAX
user.first_name	string	Имя пользователя
user.last_name	string	Фамилия пользователя
user.username	string	Ник пользователя
user.language_code	string	Язык интерфейса MAX
user.photo_url	string	Ссылка на фото профиля пользователя
chat	Chat	Объект с данными о чате, из которого открыто мини-приложение
chat.id	number	Идентификатор чата
chat.type	string	Тип чата
WebAppStartParam
Этот объект содержит дополнительные данные, которые мини-приложение получает при запуске. Данные передаются в URL мини-приложения в поле startapp?=PARAMS

Передать можно максимум 512 символов. Если символов больше, объект будет удалён из URL-ответа. Разрешены символы A-Z, a-z, 0-9, _ (подчеркивание) и - (минус)

BackButton
Этот объект управляет кнопкой Назад в шапке мини-приложения

Поле	Тип данных	Описание
isVisible	boolean	Задаёт состояние false по умолчанию
onClick()	function	Устанавливает обработчик событий
offClick()	function	Убирает обработчик событий нажатия кнопки
show()	function	Делает кнопку Назад активной и видимой
hide()	function	Скрывает кнопку Назад
ScreenCapture
Этот объект управляет возможностью делать скриншоты / записывать экран

Поле	Тип данных	Описание
isScreenCaptureEnabled	boolean	Геттер, который позволяет узнать, разрешено ли делать скриншоты / запись экрана в данный момент

true - запрещено
false - разрешено

false по умолчанию
enableScreenCapture()	function	Включить запрет на скриншоты / запись экрана
disableScreenCapture()	function	Отключить запрет на скриншоты / запись экрана
HapticFeedback
Этот объект используется для активации тактильной обратной связи при взаимодействии пользователя с веб-приложением.

Поле	Тип данных	Описание
impactOccurred(impactStyle, disableVibrationFallback)	string, boolean	Метод сообщает, что произошло воздействие.

Приложение Max может воспроизвести соответствующие тактильные эффекты на основе переданного значения стиля.

Стиль может иметь одно из следующих значений:

soft - мягкая вибрация
light - лёгкая вибрация
medium - средняя вибрация
heavy - сильная вибрация
rigid - жёсткая вибрация
notificationOccurred(notificationType, disableVibrationFallback)	string, boolean	Метод сообщает, что событие или действие выполнены успешно, не удалось или выдано предупреждение.

Приложение Max может воспроизводить соответствующие тактильные сигналы на основе переданного значения типа.

Тип может быть одним из следующих значений:

error - Указывает, что задача или действие не удалось
success - Указывает, что задача или действие были успешно завершены
warning - Указывает, что задача или действие вызвали предупреждение
selectionChanged	boolean	Метод сообщает, что пользователь изменил выбор.

Приложение Max может воспроизвести соответствующие тактильные сигналы.

Не используйте эту обратную связь, когда пользователь делает или подтверждает выбор; используйте ее только при изменении выбора.
DeviceStorage
Этот объект предоставляет мини-приложению доступ к хранилищу данных, ассоциированному с конкретным пользователем MАХ

Поле	Входные параметры	Тип данных	Описание
setItem()	key, value	string, string	Сохраняет переданную пару «ключ-значение» в локальном хранилище устройства
getItem()	key	string	Получает значение из локального хранилища устройства по указанному ключу
removeItem()	key	string	Удаляет значение из локального хранилища устройства по указанному ключу
clear()	-	-	Очищает все ключи, ранее сохранённые ботом в локальном хранилище устройства
SecureStorage
Этот объект предоставляет мини-приложению доступ к защищённому хранилищу данных

Поле	Входные параметры	Тип данных	Описание
setItem()	key, value	string, string	Сохраняет переданную пару «ключ-значение» в защищённом хранилище устройства
getItem()	key	string	Получает значение из защищённого хранилища устройства по указанному ключу
removeItem()	key	string	Удаляет значение из защищённого хранилища устройства по указанному ключу
BiometricManager
Этот объект нужен для аутентификации, когда доступ к данным в keychain получается через биометрические идентификаторы Перед первым использованием этого объекта его необходимо инициализировать с помощью метода init.

Поле	Тип данных	Описание
isInited	boolean	Была ли ранее проведена первичная инициализация
init	function	Первичная инициализация биометрии
Проверяем доступность биометрии на устройстве
Проверяем предоставлен ли доступ

Вызывается единожды при самом первом использовании.
isBiometricAvailable	boolean	Доступна ли биометрия на устройстве пользователя, который запустил мини-приложение

false, если пользователь отказался предоставить доступ к биометрии
biometricType	string[]	
fingerprint
faceid
unknown

Если пользователь отказался предоставить доступ к биометрии, biometricType=["unknown"]
Для android всегда ["unknown"]
deviceId	string | null	Идентификатор устройства (можно использовать для сопоставления токена с устройством)

null, если пользователь отказался предоставить доступ к биометрии
isAccessRequested	boolean	Был ли ранее отправлен запрос на предоставление доступа к биометрии устройства

false, если пользователь отказался предоставить доступ к биометрии
isAccessGranted	boolean	Предоставлен ли доступ к биометрии

false, если пользователь отказался предоставить доступ к биометрии
isBiometricTokenSaved	boolean	Есть ли токен в безопасном хранилище устройства

false, если пользователь отказался предоставить доступ к биометрии
requestAccess	function	Запросить доступ на использование биометрии на устройстве
authenticate	function	Для запуска процесса аутентификации
updateBiometricToken	function	Метод, который обновляет биометрический токен в безопасном хранилище на устройстве

Чтобы удалить токен, передайте пустую строку.
openSettings	function	Предложение перейти в настройки Max на экран приватности, чтобы дать доступ к биометрии устройства для мини-приложения.

Вызывает закрытие мини-приложение.
События Bridge
Название	Описание	eventData	Что отвечает
WebAppReady	Сигнализирует нативному приложению, что миниапп готов к работе.

Если контент мини-приложения не был загружен за 15 секунд - клиент отобразит экран с ошибкой "нет сети".

Если контент мини-приложения был загружен ИЛИ было вызвано событие WebAppReady на платформе - платформа отображает загруженную страницу.

Мини-приложению не требуется промис со стороны нативного клиента.	-	-
WebAppClose	Сигнализирует нативному приложению, что миниап должен быть закрыт.

Мини-приложению не требуется промис со стороны нативного клиента.	-	-
WebAppSetupBackButton	Управляет поведением кнопки назад, которая может отображаться в заголовке мини-приложения в интерфейсе MAX

isVisible = true - кнопка назад отображается

isVisible = false - кнопка назад не отображается	isVisible: boolean	-
WebAppRequestPhone	Получив это событие, клиенты должны показать пользователю сообщение, указывающее, что мини-приложение просит его поделиться своим номером телефона.

Мини-приложению требуется промис со стороны нативного клиента.	-	phone: string
WebAppSetupClosingBehavior	Управляет поведением окна с запущенным мини-приложением

needConfirmation = true - клиент должен запрашивать подтверждение пользователя с помощью всплывающего окна «Внесенные вами изменения могут быть не сохранены»

needConfirmation = false - клиент не будет запрашивать

Если явно не передано - запрашиваться не будет.	needConfirmation: boolean	-
WebAppBackButtonPressed	Уведомление о том, что кнопка "Назад" была нажата пользователем	-	-
WebAppOpenLink	Открытие ссылки во внешнем браузере	url: string	-
WebAppOpenMaxLink	Открытие диплинка MAX внутри клиента	path: string	-
WebAppShare	Нативный шаринг из мини-приложения	{ requestId: string, text: string, link: string }

Максимальная длина - 200 символов	В случае успеха:

{ requestId: string, status: "shared" }

В случае если шторка была закрыта:

{ requestId: string, status: "cancelled" }

В случае ошибки:

{ error: { code: "client.web_app_share.<reason>" } }

Возможные значения reason:
too_large_text - слишком длинный текст
too_large_link - слишком длинная ссылка
invalid_request - не передан хотя бы один параметр
WebAppMaxShare	Шаринг из мини-приложения в диалоги / групповые чаты Max	{ requestId: string, text: string, link: string }	В случае успеха:

{ requestId: string, status: "shared" }

В случае если шторка была закрыта:

{ requestId: string, status: "cancelled" }

В случае ошибки:

{ error: { code: "client.web_app_max_share.<reason>" } }

Возможные значения reason:
too_large_text - слишком длинный текст
too_large_link - слишком длинная ссылка
invalid_request - не передан хотя бы один параметр
WebAppSetupScreenCaptureBehavior	Управление возможностью делать скриншоты / записывать экран	В случае успеха:

{ requestId: string, isScreenCaptureEnabled: boolean }

Возможные значения isScreenCaptureEnabled:
true - разрешить делать скриншоты / запись экрана
false - запретить делать скриншоты / запись экрана
В случае успеха:

{ requestId: string, isScreenCaptureEnabled: boolean }
WebAppHapticFeedbackImpact	В случае когда произошел тактильный отклик (необходимо вызвать вибрацию)	В случае успеха:

{ requestId: string, impactStyle: string, disableVibrationFallback: boolean }

Возможные значения impactStyle:
soft - мягкая вибрация
light - лёгкая вибрация
medium - средняя вибрация
heavy - сильная вибрация
rigid - жёсткая вибрация


disableVibrationFallback - разрешение использовать вибрацию с постоянной амплитудой на устройствах, которые не поддерживают вибрацию с переменной амплитудой. Значение по умолчанию: false.	В случае успеха:

{ requestId: string, status: "impactOccured" }

В случае ошибки:

{ error: { code: "client.haptic_feedback_impact.<reason>" } }

Возможные значения reason:
not_supported - haptic feedback недоступен на устройстве
invalid_impact_style - передан неизвестный impact style
WebAppHapticFeedbackNotification	В случае когда событие или действие выполнены успешно, не выполнены или выдано предупреждение	В случае успеха:

{ requestId: string, fileSelect: boolean }

Возможные значения notificationType:
error - Указывает, что задача или действие не удалось
success - Указывает, что задача или действие были успешно завершены
warning - Указывает, что задача или действие вызвали предупреждение


disableVibrationFallback - разрешение использовать вибрацию с постоянной амплитудой на устройствах, которые не поддерживают вибрацию с переменной амплитудой. Значение по умолчанию: false.	В случае успеха:

{ requestId: string, status: "notificationOccured" }

В случае ошибки:

{ error: { code: "client.haptic_feedback_notification.<reason>" } }

Возможные значения reason:
not_supported - haptic feedback недоступен на устройстве
invalid_notification_type - передан неизвестный notification type
WebAppHapticFeedbackSelectionChange	Сообщает генератору виброотклика, что пользователь изменил выбор.	В случае успеха:

{ requestId: string, disableVibrationFallback: boolean }

disableVibrationFallback - разрешение использовать вибрацию с постоянной амплитудой на устройствах, которые не поддерживают вибрацию с переменной амплитудой. Значение по умолчанию: false.	В случае успеха:

{ requestId: string, status: "selectionChanged" }

В случае ошибки:

{ error: { code: "client.haptic_feedback_selection_change.<reason>" } }

Возможные значения reason:
not_supported - haptic feedback недоступен на устройстве
WebAppOpenCodeReader	
Открывает камеру для считывания QR кода и получает результат сканирования.

Клиент не имеет возможности ответить, что код не был найден.
В случае успеха:

{ requestId: string, fileSelect: boolean }

fileSelect = true - доступен так же выбор из галереи
fileSelect = false - доступно сканирование только через камеру
В случае успеха:

{ requestId: string, value: string }

В случае ошибки:

{ error: { code: "client.open_code_reader.<reason>" } }

Возможные значения reason:
not_supported - на устройстве нет камеры
permission_denied - пользователь не дал доступ к камере
cancelled - пользователь закрыл камеру
WebAppDownloadFile
в разработке	Позволяет скачивать файлы на устройство пользователя	-	-
WebAppCopyText
в разработке	Копирует переданный текст в буфер обмена	-	-

ℹ️ Если у вас возникли вопросы, посмотрите раздел с ответами

Валидация данных
MAX передаёт стартовые параметры мини-приложению с каждым запуском. Чтобы убедиться, что эти данные принадлежат реальным людям и не были изменены или скомпрометированы, рекомендуем проверять их подлинность через процедуру валидации

Валидация данных на стороне мини-приложения
С запуском мини-приложения его клиентская часть получает закодированную строку для валидации данных через WebAppData

Мини-приложение извлекает данные, которые должны быть провалидированы. Эти же данные можно считать через глобальный объект window.WebApp.InitData

Пример строки с данными Init Data

Код
auth_date%3D1733485316394%26query_id%3D158b120b-7aa3-4a0f-a198-52ace06d0658%26user%3D%257B%2522language_code%2522%253A%2522ru%2522%252C%2522first_name%2522%253A%2522%25D0%2592%25D0%25B0%25D1%2581%25D1%258F%2522%252C%2522last_name%2522%253A%2522%2522%252C%2522photo_url%2522%253Anull%252C%2522username%2522%253Anull%252C%2522id%2522%253A400%257D%26hash%3Df982406d90b118d8e90e26b33c5cec0cadd3fc30354f2955c75ff8e3d14d130d
Подготавливаем данные к валидации:
Производим URL-декодирование
Перебираем все значения и объединяем их в строку парами в формате {key}={value}
Исключаем hash
Сортируем вычисленный массив в алфавитном порядке и объединяем в строку. В качестве разделителя используем '\n' (0x0A)

Пример подготовленных данных Init Data
Код
auth_date=1662771648\nquery_id=AAHdF6IQAAAAAN0XohDhrOrc\nuser={"id":279058397,"first_name":"","last_name":"","username":"vdkfrost","language_code":"ru",
 
// hash
'f982406d90b118d8e90e26b33c5cec0cadd3fc30354f2955c75ff8e3d14d130d'
Создаём ключ шифрования (secret_key) с помощью алгоритма хеширования HMAC-SHA256. Используем ключ WebAppData и токен, выданный при создании чат-бота на платформе MAX для партнёров

HMAC_SHA256(“WebAppData” + “Bot Token”)
Код
HMAC_SHA256(
"WebAppData", 
"2Uk3Z_8zAlwhprgOcK3r1B1fDk8uhi2MDv47EvXkcu8" // Bot Token
) = "2acdf1cf8727a58bfad2dfd1129144a464e3ce73aee3d120e499d1dbb0683e31"
Вычисляем подпись (hash) стартовых параметров Init Data. Для этого создадим ещё одну подпись с помощью алгоритма хеширования HMAC-SHA256: используем отсортированные пары {key}={value} и ключ шифрования (secret_key) в качестве криптографического ключа в шестнадцатеричном формате. Результат преобразуем в строку с помощью функции hex
hex(HMAC_SHA256(secret_key, data_check_string))

Код
hex(HMAC-SHA256(
"2acdf1cf8727a58bfad2dfd1129144a464e3ce73aee3d120e499d1dbb0683e31",
"auth_date=1733485316394\nquery_id=158b120b-7aa3-4a0f-a198-52ace06d0658\nuser={\"language_code\":\"ru\",\"  first_name\":\"\",\"last_name\":\"\",\"photo_url\":null,\"username\":null,\"id\":400}"
)) = "f982406d90b118d8e90e26b33c5cec0cadd3fc30354f2955c75ff8e3d14d130d"
Сравниваем получившийся результат: если полученная подпись совпадает с hash из Init Data, данные подлинные. Если нет — данные были изменены

ℹ️ Если у вас возникли вопросы, посмотрите раздел с ответами